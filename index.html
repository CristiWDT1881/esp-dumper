<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>ESP32 Flash Dumper & Writer</title>
    <style>
        * { margin:0; padding:0; box-sizing:border-box; }
        body {
            font-family: "Segoe UI", Arial, sans-serif;
            background-color: #1a5f3f;
            min-height:100vh;
            padding:20px;
            display:flex;
            flex-direction:column;
            align-items:center;
        }
        .header-images{ display:flex; justify-content:space-between; align-items:flex-start; width:100%; max-width:700px; margin-bottom:40px;}
        .header-images img{ max-width:180px; height:auto; border-radius:10px; box-shadow:0 4px 15px rgba(0,0,0,0.3); border:4px solid #5B9BD5; }
        .container{ max-width:700px; width:100%; }
        h1{ color:#FFD700; font-size:2.5em; text-align:center; margin:20px 0; text-shadow:2px 2px 4px rgba(0,0,0,0.3); }
        .section{ background:#B3D9F2; border-radius:15px; padding:20px; margin-bottom:15px; box-shadow:0 8px 30px rgba(0,0,0,0.3); border:4px solid #5B9BD5; }
        .section.first-box{ display:flex; gap:20px; align-items:flex-start; padding:10px 20px; }
        .section-content{ flex:1; }
        .signature-img{ width:130px; height:auto; border-radius:10px; box-shadow:0 4px 15px rgba(0,0,0,0.2); border:4px solid #5B9BD5; }
        .section h2{ color:#1a5f3f; font-size:1.3em; margin-bottom:10px; }
        .section p{ color:#000; font-size:0.95em; margin-bottom:5px; }
        .control-group{ margin-bottom:10px; }
        .control-group label{ color:#1a5f3f; font-weight:bold; display:block; margin-bottom:5px; }
        select, input[type="file"]{ width:100%; padding:8px; border:3px solid #5B9BD5; border-radius:8px; background:white; }
        .button-group{ display:flex; gap:10px; margin-top:10px; flex-wrap:wrap; }
        button{ flex:1; min-width:180px; padding:12px; font-size:1.1em; font-weight:bold; border:none; border-radius:12px; cursor:pointer; transition:all 0.3s; box-shadow:0 6px 20px rgba(0,0,0,0.3); }
        .btn-connect{ background:#1a5f3f; color:white; } .btn-connect:hover{ background:#145030; transform:translateY(-2px); }
        .btn-disconnect{ background:#6c757d; color:white; }
        .btn-read, .btn-write{ background:#5B9BD5; color:#000; } .btn-read:hover, .btn-write:hover{ background:#FFD700; transform:translateY(-2px); }
        button:disabled{ opacity:0.5; cursor:not-allowed; transform:none !important; }
        .status{ background:white; padding:10px; border-radius:8px; margin-bottom:10px; border:3px solid #5B9BD5; font-weight:500; }
        .status.connected{ border-color:#1a5f3f; background:#d4edda; }
        .status.working{ border-color:#FFD700; background:#fff3cd; }
        .status.error{ border-color:#dc3545; background:#f8d7da; }
        .progress-bar{ width:100%; height:30px; background:white; border-radius:8px; border:3px solid #5B9BD5; overflow:hidden; margin:10px 0; display:none; }
        .progress-bar.active{ display:block; }
        .progress-fill{ height:100%; background:linear-gradient(90deg,#1a5f3f,#5B9BD5); width:0%; transition:width 0.3s; display:flex; align-items:center; justify-content:center; color:white; font-weight:bold; }
        .log-container{ background:#1e1e1e; color:#00ff00; padding:15px; border-radius:8px; max-height:400px; overflow-y:auto; font-family:'Courier New', monospace; font-size:0.9em; line-height:1.6; }
        .log-entry{ margin-bottom:3px; } .log-entry.error{ color:#ff6b6b; } .log-entry.success{ color:#51cf66; } .log-entry.warning{ color:#ffd43b; } .log-entry.info{ color:#74c0fc; }
        .radio-links{ display:flex; justify-content:space-around; align-items:center; gap:30px; flex-wrap:wrap; }
        .radio-link{ display:flex; flex-direction:column; align-items:center; text-decoration:none; transition:transform 0.3s; } .radio-link:hover{ transform:scale(1.1); }
        .radio-link img{ width:120px; height:120px; border-radius:15px; box-shadow:0 4px 15px rgba(0,0,0,0.2); margin-bottom:10px; border:4px solid #5B9BD5; }
        .radio-link span{ color:#000; font-weight:bold; font-size:1.1em; }
        @media (max-width:768px){ .header-images{ flex-direction:column; align-items:center; gap:15px; } h1{ font-size:2em; } }
    </style>
</head>
<body>
    <div class="header-images">
        <img src="./palatiasi.png" alt="Palatul Culturii" onerror="this.style.display='none'">
        <img src="./logo.png" alt="Logo" onerror="this.style.display='none'">
    </div>

    <div class="container">
        <h1>ESP32 Flash Dumper & Writer</h1>

        <div class="section first-box">
            <div class="section-content">
                <h2>üì° Connect Device</h2>
                <div id="status" class="status">Status: Disconnected</div>

                <div class="control-group">
                    <label>Detected Device:</label>
                    <div id="detected" style="padding:8px;background:#fff;border:3px solid #5B9BD5;border-radius:8px;">-</div>
                </div>

                <div class="control-group">
                    <label>Baud Rate:</label>
                    <select id="baudRate">
                        <option value="115200">115200</option>
                        <option value="230400">230400</option>
                        <option value="460800">460800</option>
                        <option value="921600" selected>921600</option>
                        <option value="1500000">1500000</option>
                    </select>
                </div>

                <div class="button-group">
                    <button id="connectBtn" class="btn-connect">CONNECT</button>
                    <button id="disconnectBtn" class="btn-disconnect" disabled>DISCONNECT</button>
                </div>
            </div>
            <img src="./semnatura.png" alt="Signature" class="signature-img" onerror="this.style.display='none'">
        </div>

        <div class="section">
            <h2>üì• Happy Read - Dump Flash</h2>
            <p><strong>1.</strong> Connect device via USB</p>
            <p><strong>2.</strong> Click HAPPY READ to dump entire flash</p>
            <p><strong>3.</strong> File will be saved to Downloads</p>

            <div class="button-group">
                <button id="dumpBtn" class="btn-read" disabled>üì• HAPPY READ</button>
                <button id="resumeBtn" class="btn-read" disabled>‚ñ∂Ô∏è RESUME</button>
            </div>

            <div id="dumpProgress" class="progress-bar">
                <div id="dumpProgressFill" class="progress-fill">0%</div>
            </div>
        </div>

        <div class="section">
            <h2>‚òÅÔ∏è Happy Backup Dump on GitHub</h2>
            <p><strong>1.</strong> First do HAPPY READ to create dump</p>
            <p><strong>2.</strong> Click button below to backup to GitHub</p>
            <p><strong>3.</strong> Enter password when prompted</p>

            <div class="button-group">
                <button id="githubBackupBtn" class="btn-write" disabled>‚òÅÔ∏è HAPPY BACKUP DUMP ON GITHUB</button>
            </div>

            <div id="githubProgress" class="progress-bar">
                <div id="githubProgressFill" class="progress-fill">0%</div>
            </div>
        </div>

        <div class="section">
            <h2>üì§ Happy Write - Write Flash</h2>
            <p><strong>1.</strong> Select firmware file (.bin)</p>
            <p><strong>2.</strong> Click HAPPY WRITE</p>
            <p><strong>3.</strong> Choose erase option when prompted</p>

            <div class="control-group">
                <label>Select Firmware File:</label>
                <input type="file" id="writeFile" accept=".bin">
            </div>

            <div class="button-group">
                <button id="writeBtn" class="btn-write" disabled>üì§ HAPPY WRITE</button>
            </div>

            <div id="writeProgress" class="progress-bar">
                <div id="writeProgressFill" class="progress-fill">0%</div>
            </div>
        </div>

        <div class="section">
            <h2>üìã Operation Log</h2>
            <div id="logContainer" class="log-container">
                <div class="log-entry info">System initialized. Connect device to start...</div>
            </div>
        </div>

        <div class="section">
            <h2>üìª Radio Live</h2>
            <div class="radio-links">
                <a href="https://www.radioromaniacultural.ro/live/" target="_blank" class="radio-link">
                    <img src="./logocultural.svg" alt="Radio Rom√¢nia Cultural" onerror="this.style.display='none'">
                    <span>Cultural</span>
                </a>
                <a href="http://player.radioiasi.ro/live-radio-iasi.html" target="_blank" class="radio-link">
                    <img src="./logoriasi.svg" alt="Radio Ia»ôi" onerror="this.style.display='none'">
                    <span>Radio Ia»ôi</span>
                </a>
            </div>
        </div>
    </div>

    <!-- FileSaver -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

    <script type="module">
    // Final JS: preserves UI, reliable connect (from your working snippet),
    // detects flash size (4/8/16/32 MB) and reads exactly that amount,
    // writes safe, supports resume, keeps logs, no extra UI choices.

    import { ESPLoader, Transport } from "https://unpkg.com/esptool-js@0.4.5/bundle.js";

    // --- State & elements ---
    const state = {
      port: null,
      transport: null,
      esploader: null,
      chip: null,
      connected: false,
      flashBytes: 0,
      dumpBuffer: null,
      dumpOffset: 0,
      isOperating: false
    };

    const CHUNK = 4096; // read/write chunk

    const el = {
      status: document.getElementById('status'),
      detected: document.getElementById('detected'),
      baudRate: document.getElementById('baudRate'),
      connectBtn: document.getElementById('connectBtn'),
      disconnectBtn: document.getElementById('disconnectBtn'),
      dumpBtn: document.getElementById('dumpBtn'),
      resumeBtn: document.getElementById('resumeBtn'),
      githubBackupBtn: document.getElementById('githubBackupBtn'),
      writeBtn: document.getElementById('writeBtn'),
      writeFile: document.getElementById('writeFile'),
      logContainer: document.getElementById('logContainer'),
      dumpProgress: document.getElementById('dumpProgress'),
      dumpProgressFill: document.getElementById('dumpProgressFill'),
      writeProgress: document.getElementById('writeProgress'),
      writeProgressFill: document.getElementById('writeProgressFill'),
      githubProgress: document.getElementById('githubProgress'),
      githubProgressFill: document.getElementById('githubProgressFill')
    };

    function log(msg, type='info') {
      const time = new Date().toLocaleTimeString('ro-RO');
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.textContent = `[${time}] ${msg}`;
      el.logContainer.appendChild(entry);
      el.logContainer.scrollTop = el.logContainer.scrollHeight;
      // also console for debugging
      if (type === 'error') console.error(msg);
      else console.log(msg);
    }

    function setStatus(text, cls='') {
      el.status.textContent = text;
      el.status.className = `status ${cls}`;
    }

    function setDetected(text) {
      el.detected.textContent = text;
    }

    function updateProgress(barEl, fillEl, percent, text) {
      barEl.classList.add('active');
      fillEl.style.width = percent + '%';
      fillEl.textContent = text || percent + '%';
    }
    function hideProgress(barEl) { barEl.classList.remove('active'); }

    // --- Helpers: safe close to avoid "port already open" ---
    async function safeDisconnectTransport() {
      try {
        if (state.transport && typeof state.transport.disconnect === 'function') {
          await state.transport.disconnect();
        }
      } catch (e) { /* ignore */ }
      try {
        if (state.port && typeof state.port.close === 'function') {
          await state.port.close();
        }
      } catch (e) { /* ignore */ }
      state.transport = null;
      state.esploader = null;
      state.port = null;
      state.chip = null;
      state.connected = false;
    }

    // --- Flash size detection (tries flashId, then chip info, fallback to common sizes) ---
    async function detectFlashBytes() {
      // try esploader.flashId()
      try {
        if (state.esploader && typeof state.esploader.flashId === 'function') {
          const id = await state.esploader.flashId();
          // id often array [manu, type, capacityCode]
          if (Array.isArray(id) && id.length >= 3) {
            const cap = id[2];
            // mapping typical codes -> MB (common)
            const map = { 0x12: 4, 0x13: 8, 0x14: 8, 0x15: 16, 0x16: 32 };
            if (map[cap]) return map[cap] * 1024 * 1024;
          }
        }
      } catch (e) {
        // ignore; we'll try other heuristics
      }
      // try chip info (esptool-js might expose flash device info)
      try {
        if (state.chip && state.chip.FlashDevice && state.chip.FlashDevice.capacity) {
          return state.chip.FlashDevice.capacity;
        }
      } catch (e) { /* ignore */ }
      // fallback common values: try 4MB first
      return 16 * 1024 * 1024; // default fallback (but we prefer detection)
    }

    // --- Connect ---
    async function connect() {
      if (state.isOperating) return;
      try {
        // cleanup previous if any
        await safeDisconnectTransport();

        if (!('serial' in navigator)) {
          alert('Web Serial API nu e disponibil √Æn browser. Folose»ôte Chrome/Edge.');
          return;
        }

        setStatus('Connecting...', 'working');
        log('Requesting port...', 'info');

        // Request port (no filters to support many boards)
        state.port = await navigator.serial.requestPort();
        const info = state.port.getInfo();
        log(`Port: VendorID 0x${info.usbVendorId?.toString(16)} ProductID 0x${info.usbProductId?.toString(16)}`, 'info');

        // ensure port is closed before open to avoid InvalidStateError
        try { if (state.port && typeof state.port.close === 'function') await state.port.close(); } catch(e){ /* ignore */ }

        // open with selected baud
        const baud = parseInt(el.baudRate.value) || 115200;
        await state.port.open({ baudRate: baud });

        // create transport + esploader
        state.transport = new Transport(state.port, true);
        state.esploader = new ESPLoader({ transport: state.transport, baudrate: baud, romBaudrate: 115200, terminal: { writeLine: log, write: log, clean: () => {} } });

        log('Detecting chip...', 'info');
        // try main with retries
        let retries = 3;
        let lastErr = null;
        while (retries > 0) {
          try {
            state.chip = await state.esploader.main();
            break;
          } catch (e) {
            lastErr = e;
            retries--;
            if (retries > 0) {
              log(`Retry ${4 - retries}/3...`, 'warning');
              await new Promise(r => setTimeout(r, 800));
            }
          }
        }
        if (!state.chip) throw lastErr || new Error('Nu s-a putut detecta chip-ul');

        state.connected = true;
        const chipName = state.chip?.CHIP_NAME || 'ESP32';
        log(`‚úÖ Connected: ${chipName}`, 'success');

        // read MAC if possible
        try { const mac = await state.esploader.readMac(); log(`MAC: ${mac}`, 'info'); } catch (e) { /* ignore */ }

        // detect flash bytes and update UI
        const detectedBytes = await detectFlashBytes();
        state.flashBytes = detectedBytes || (16 * 1024 * 1024);
        const mb = Math.round(state.flashBytes / (1024 * 1024));
        setDetected(`${chipName} ‚Äî flash: ${mb} MB`);
        log(`Detected flash size: ${mb} MB`, 'info');

        // update controls
        setStatus(`‚úÖ ${chipName}`, 'connected');
        el.connectBtn.disabled = true;
        el.disconnectBtn.disabled = false;
        el.dumpBtn.disabled = false;
        el.writeBtn.disabled = false;
        el.githubBackupBtn.disabled = false;
        el.resumeBtn.disabled = true; // resume becomes enabled only if partial dump exists

      } catch (e) {
        log(`ERR: ${e?.message || e}`, 'error');
        setStatus('‚ùå Failed', 'error');
        // cleanup
        try { await safeDisconnectTransport(); } catch (ee) {}
        el.connectBtn.disabled = false;
        el.disconnectBtn.disabled = true;
        el.dumpBtn.disabled = true;
        el.writeBtn.disabled = true;
        el.githubBackupBtn.disabled = true;
      }
    }

    // --- Disconnect ---
    async function disconnect() {
      try {
        log('Disconnecting...', 'info');
        await safeDisconnectTransport();
        setStatus('Disconnected', '');
        setDetected('-');
        el.connectBtn.disabled = false;
        el.disconnectBtn.disabled = true;
        el.dumpBtn.disabled = true;
        el.writeBtn.disabled = true;
        el.githubBackupBtn.disabled = true;
        el.resumeBtn.disabled = true;
        log('‚úÖ Disconnected', 'success');
      } catch (e) {
        log(`Disconnect error: ${e.message}`, 'error');
      }
    }

    // --- Read full flash (from 0x00000) ---
    async function happyRead() {
      if (!state.connected || state.isOperating) return;
      try {
        state.isOperating = true;
        el.dumpBtn.disabled = true;
        el.resumeBtn.disabled = true;
        el.writeBtn.disabled = true;
        setStatus('üì• Reading...', 'working');
        log('Starting full flash read from 0x00000...', 'info');

        const flashBytes = state.flashBytes;
        state.dumpBuffer = new Uint8Array(flashBytes);
        state.dumpOffset = 0;

        // read in chunks (CHUNK)
        for (let addr = 0; addr < flashBytes; addr += CHUNK) {
          const readSize = Math.min(CHUNK, flashBytes - addr);
          const block = await state.esploader.readFlash(addr, readSize);
          state.dumpBuffer.set(new Uint8Array(block), addr);
          state.dumpOffset = addr + readSize;
          const pct = Math.floor((state.dumpOffset / flashBytes) * 100);
          updateProgress(el.dumpProgress, el.dumpProgressFill, pct, `${pct}% - ${Math.floor(state.dumpOffset/1024)} KB`);
          if (addr % Math.max(CHUNK, Math.floor(flashBytes/10)) === 0) log(`${pct}% read`, 'info');
        }

        // save file
        const ts = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
        const name = (state.chip?.CHIP_NAME || 'esp') + `_dump_${ts}.bin`;
        saveAs(new Blob([state.dumpBuffer]), name);
        log(`‚úÖ Saved: ${name}`, 'success');
        setStatus('‚úÖ Done!', 'connected');

        // enable backup and reset resume
        el.githubBackupBtn.disabled = false;
        el.resumeBtn.disabled = true;
      } catch (e) {
        log(`Read Error: ${e.message}`, 'error');
        setStatus('‚ùå Failed', 'error');
        // allow resume if partial data exists
        if (state.dumpBuffer && state.dumpOffset > 0) {
          el.resumeBtn.disabled = false;
          log('Partial dump available ‚Äî you can RESUME after reconnecting.', 'warning');
        }
      } finally {
        state.isOperating = false;
        el.dumpBtn.disabled = false;
        el.writeBtn.disabled = false;
        setTimeout(() => hideProgress(el.dumpProgress), 2000);
      }
    }

    // --- Resume previously interrupted read ---
    async function resumeRead() {
      if (!state.connected || state.isOperating) return;
      if (!state.dumpBuffer) { log('Nu existƒÉ dump par»õial pentru resume.', 'warning'); return; }
      try {
        state.isOperating = true;
        el.resumeBtn.disabled = true;
        el.dumpBtn.disabled = true;
        setStatus('üîÅ Resuming...', 'working');
        log('Resuming read from offset ' + state.dumpOffset, 'info');

        const flashBytes = state.dumpBuffer.length;
        for (let addr = state.dumpOffset; addr < flashBytes; addr += CHUNK) {
          const readSize = Math.min(CHUNK, flashBytes - addr);
          const block = await state.esploader.readFlash(addr, readSize);
          state.dumpBuffer.set(new Uint8Array(block), addr);
          state.dumpOffset = addr + readSize;
          const pct = Math.floor((state.dumpOffset / flashBytes) * 100);
          updateProgress(el.dumpProgress, el.dumpProgressFill, pct, `${pct}% - ${Math.floor(state.dumpOffset/1024)} KB`);
          if (addr % Math.max(CHUNK, Math.floor(flashBytes/10)) === 0) log(`${pct}% resumed`, 'info');
        }

        const ts = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
        const name = (state.chip?.CHIP_NAME || 'esp') + `_dump_resumed_${ts}.bin`;
        saveAs(new Blob([state.dumpBuffer]), name);
        log(`‚úÖ Resume saved: ${name}`, 'success');
        setStatus('‚úÖ Done!', 'connected');
        el.githubBackupBtn.disabled = false;
      } catch (e) {
        log(`Resume Error: ${e.message}`, 'error');
        setStatus('‚ùå Failed', 'error');
        el.resumeBtn.disabled = false;
      } finally {
        state.isOperating = false;
        el.dumpBtn.disabled = false;
        setTimeout(() => hideProgress(el.dumpProgress), 2000);
      }
    }

    // --- Write (safe) ---
    async function happyWrite() {
      if (!state.connected || state.isOperating) return;
      const f = el.writeFile.files[0];
      if (!f) { alert('Select firmware .bin first'); return; }
      try {
        const buf = await f.arrayBuffer();
        const data = new Uint8Array(buf);

        // check size
        if (data.length > state.flashBytes) {
          alert('Fi»ôierul este mai mare dec√¢t memoria flash detectatƒÉ ‚Äî abort.');
          log('Write blocked: file exceeds flash size', 'error');
          return;
        }

        const doErase = confirm('Erase entire flash before write?\n‚úÖ YES\n‚ùå NO');
        state.isOperating = true;
        setStatus('üì§ Writing...', 'working');
        el.writeBtn.disabled = true;
        el.dumpBtn.disabled = true;

        if (doErase) {
          log('Erasing flash...', 'warning');
          updateProgress(el.writeProgress, el.writeProgressFill, 0, 'Erasing...');
          await state.esploader.eraseFlash();
          log('‚úÖ Erased', 'success');
        }

        updateProgress(el.writeProgress, el.writeProgressFill, 10, 'Writing...');
        // write at address 0 by default (user can change file layout manually outside UI if needed)
        await state.esploader.writeFlash({ fileArray: [{ data, address: 0 }], flashSize: 'keep', eraseAll: false, compress: true,
          reportProgress: (idx, written, total) => {
            const pct = Math.floor((written / total) * 100);
            updateProgress(el.writeProgress, el.writeProgressFill, pct, `${pct}% - ${Math.floor(written/1024)} KB`);
          }});
        updateProgress(el.writeProgress, el.writeProgressFill, 100, '100%!');
        log('‚úÖ Write complete!', 'success');
        setStatus('‚úÖ Done!', 'connected');
      } catch (e) {
        log(`Write Error: ${e.message}`, 'error');
        setStatus('‚ùå Failed', 'error');
      } finally {
        state.isOperating = false;
        el.writeBtn.disabled = false;
        el.dumpBtn.disabled = false;
        setTimeout(() => hideProgress(el.writeProgress), 2000);
      }
    }

    // --- Backup to GitHub (placeholder: do NOT embed real tokens in client) ---
    async function backupGitHub() {
      if (!state.dumpBuffer) { alert('FƒÉ mai √Ænt√¢i HAPPY READ'); return; }
      const pwd = prompt('Password pentru backup:');
      if (!pwd) return;
      // Placeholder check - in production, do upload via backend
      alert('Upload to GitHub must be done via backend. This client shows the data is ready.');
      log('Backup requested (client) ‚Äî implement server-side upload for security', 'info');
      // If you want a naive client attempt (not recommended) you can implement chunked PUTs with a token.
    }

    // --- Attach events ---
    el.connectBtn.addEventListener('click', connect);
    el.disconnectBtn.addEventListener('click', disconnect);
    el.dumpBtn.addEventListener('click', happyRead);
    el.resumeBtn.addEventListener('click', resumeRead);
    el.writeBtn.addEventListener('click', happyWrite);
    el.githubBackupBtn.addEventListener('click', backupGitHub);

    // initial UI state
    setStatus('Disconnected', '');
    setDetected('-');
    el.disconnectBtn.disabled = true;
    el.dumpBtn.disabled = true;
    el.resumeBtn.disabled = true;
    el.writeBtn.disabled = true;
    el.githubBackupBtn.disabled = true;

    log('ESP32 Flash Dumper & Writer ready', 'success');
    log('ApasƒÉ CONNECT pentru a porni', 'info');

    </script>
</body>
</html>
