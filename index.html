ashSize} MB (${state.detectedFlashBytes} bytes)`, 'info');
    log(`→ MAC Address: ${state.macAddress}`, 'info');
    log(`→ Features: ${state.chipFeatures || 'N/A'}`, 'info');
    
  } catch (e) {
    log(`Connect error: ${e.message}`, 'error');
    updateStatus('Connection Failed', 'error');
    alert(`Eroare: ${e.message}`);
  }
}

async function disconnect() {
  try {
    if (state.transport) await state.transport.disconnect();
    state.connected = false;
    state.logBuffer = [];
    updateStatus('Disconnected');
    el.deviceInfo.style.display = 'none';
    el.connectBtn.disabled = false; 
    el.disconnectBtn.disabled = true;
    el.dumpBtn.disabled = el.writeBtn.disabled = true;
    log('Disconnected from device', 'info');
  } catch (e) { 
    log(`Disconnect error: ${e.message}`, 'error'); 
  }
}

async function happyRead() {
  if (!state.connected || state.isOperating) return;
  
  try {
    state.isOperating = true; 
    el.dumpBtn.disabled = true;
    updateStatus('Reading flash...','working');

    const size = getEffectiveFlashBytes();
    const sizeMB = getEffectiveFlashSize();
    
    log(`┌────────────────────────────────────────┐`, 'info');
    log(`Starting flash dump for ${state.chipFamily}`, 'info');
    log(`Flash size: ${sizeMB} MB (${size} bytes)`, 'info');
    
    const data = new Uint8Array(size);
    
    let chunk;
    if (sizeMB >= 16) {
      chunk = 0x4000;
      log('⚡ Using optimized 16KB chunks for 16MB flash', 'info');
    } else if (sizeMB >= 8) {
      chunk = 0x4000;
      log('⚡ Using optimized 16KB chunks for 8MB flash', 'info');
    } else if (state.chipFamily === 'ESP8266') {
      chunk = 0x1000;
      log('Using ESP8266 optimized 4KB chunks', 'info');
    } else {
      chunk = 0x4000;
      log('Using standard 16KB chunks', 'info');
    }

    const startTime = Date.now();
    let lastLogPercent = -5;
    const MAX_RETRIES = 3;
    let consecutiveErrors = 0;
    
    log(`└────────────────────────────────────────┘`, 'info');
    
    for (let offset = 0; offset < size; offset += chunk) {
      const blockSize = Math.min(chunk, size - offset);
      let success = false;
      let attempts = 0;
      
      while (!success && attempts < MAX_RETRIES) {
        try {
          const block = await state.esploader.readFlash(offset, blockSize);
          data.set(new Uint8Array(block), offset);
          success = true;
          consecutiveErrors = 0;
        } catch (e) {
          attempts++;
          consecutiveErrors++;
          
          if (consecutiveErrors >= 10) {
            throw new Error(`Too many errors. Last: ${e.message}`);
          }
          
          if (attempts < MAX_RETRIES) {
            await new Promise(resolve => setTimeout(resolve, 100 * attempts));
          } else {
            throw new Error(`Failed at 0x${offset.toString(16)} after ${MAX_RETRIES} attempts: ${e.message}`);
          }
        }
      }
      
      const progress = ((offset + blockSize) / size) * 100;
      updateProgress(el.dumpProgress, el.dumpProgressFill, progress);
      
      const currentPercent = Math.floor(progress);
      if (currentPercent - lastLogPercent >= 5) {
        const elapsedSec = (Date.now() - startTime) / 1000;
        const mbRead = (offset + blockSize) / (1024 * 1024);
        const speed = mbRead / elapsedSec;
        const remaining = (size - offset - blockSize) / (1024 * 1024);
        const etaSec = Math.ceil(remaining / speed);
        const etaMin = Math.floor(etaSec / 60);
        const etaSecRem = etaSec % 60;
        
        log(`${currentPercent}% | ${mbRead.toFixed(1)}/${sizeMB} MB | ${speed.toFixed(2)} MB/s | ETA: ${etaMin}:${etaSecRem.toString().padStart(2,'0')}`, 'info');
        lastLogPercent = currentPercent;
      }
      
      if (offset % (256 * 1024) === 0) {
        await new Promise(resolve => setTimeout(resolve, 0));
      }
    }

    const totalTime = ((Date.now() - startTime) / 1000).toFixed(1);
    const avgSpeed = (sizeMB / parseFloat(totalTime)).toFixed(2);
    const filename = `${state.chipFamily}_${state.macAddress.replace(/:/g, '-')}_${sizeMB}MB_${new Date().toISOString().slice(0,10)}.bin`;
    
    const blob = new Blob([data], { type: 'application/octet-stream' });
    saveAs(blob, filename);
    
    state.lastDumpData = data; 
    state.lastDumpFilename = filename;

    updateProgress(el.dumpProgress, el.dumpProgressFill, 100, 'Complete!');
    setTimeout(() => hideProgress(el.dumpProgress), 2000);
    
    log(`┌────────────────────────────────────────┐`, 'success');
    log(`✓ DUMP COMPLETE!`, 'success');
    log(`→ File: ${filename}`, 'success');
    log(`→ Size: ${sizeMB} MB`, 'success');
    log(`→ Time: ${totalTime}s (${avgSpeed} MB/s)`, 'success');
    log(`→ Saved to Downloads`, 'success');
    log(`└────────────────────────────────────────┘`, 'success');
    
    updateStatus(`Read complete: ${filename}`, 'connected');
  } catch (e) { 
    log(`✗ Read error: ${e.message}`, 'error');
    updateStatus('Read failed', 'error');
    alert(`Read error: ${e.message}\n\nTry disconnecting and reconnecting.`);
  } finally { 
    state.isOperating = false; 
    el.dumpBtn.disabled = false; 
  }
}

async function happyWrite() {
  if (!state.connected || state.isOperating) return;
  
  const file = el.writeFile.files[0];
  if (!file) {
    alert('Please select a firmware file first!');
    return;
  }

  const fileSize = file.size;
  const flashSize = getEffectiveFlashBytes();
  
  const minSize = flashSize * 0.75;
  const maxSize = flashSize * 1.25;
  
  if (fileSize < minSize || fileSize > maxSize) {
    const proceed = confirm(
      `⚠️ WARNING: Size Mismatch ⚠️\n\n` +
      `File size: ${(fileSize/1024/1024).toFixed(2)} MB\n` +
      `Flash size: ${getEffectiveFlashSize()} MB\n\n` +
      `This firmware may be incompatible with ${state.chipFamily}.\n\n` +
      `Continue anyway?`
    );
    if (!proceed) {
      log('Write cancelled - size mismatch', 'warning');
      return;
    }
  }

  try {
    state.isOperating = true;
    el.writeBtn.disabled = true;
    updateStatus('Reading firmware...', 'working');
    
    log(`┌────────────────────────────────────────┐`, 'info');
    log(`Starting firmware write to ${state.chipFamily}`, 'info');
    log(`Firmware: ${file.name}`, 'info');
    log(`Size: ${(fileSize/1024/1024).toFixed(2)} MB`, 'info');
    log(`└────────────────────────────────────────┘`, 'info');

    const arrayBuffer = await file.arrayBuffer();
    
    const confirmWrite = window.confirm(
      `⚠️ FINAL WARNING ⚠️\n\n` +
      `This will ERASE and WRITE the entire flash!\n\n` +
      `Chip: ${state.chipType}\n` +
      `Firmware: ${file.name}\n` +
      `Size: ${(fileSize/1024/1024).toFixed(2)} MB\n\n` +
      `Continue?`
    );

    if (!confirmWrite) {
      log('Write cancelled by user', 'warning');
      state.isOperating = false;
      el.writeBtn.disabled = false;
      return;
    }

    updateStatus('Erasing flash...', 'working');
    log('Erasing flash (10-30 seconds)...', 'warning');
    updateProgress(el.writeProgress, el.writeProgressFill, 5, 'Erasing...');

    await state.esploader.eraseFlash();
    log('✓ Flash erased!', 'success');

    updateStatus('Writing firmware...', 'working');
    log('Writing firmware...', 'info');
    updateProgress(el.writeProgress, el.writeProgressFill, 10, 'Writing...');

    const uint8Array = new Uint8Array(arrayBuffer);
    let binaryString = '';
    for (let i = 0; i < uint8Array.length; i++) {
      binaryString += String.fromCharCode(uint8Array[i]);
    }

    const fileArray = [{
      data: binaryString,
      address: 0x0
    }];

    let lastLogPercent = 0;
    const startTime = Date.now();

    await state.esploader.writeFlash({
      fileArray: fileArray,
      flashSize: 'keep',
      flashMode: 'keep',
      flashFreq: 'keep',
      eraseAll: false,
      compress: true,
      reportProgress: (fileIndex, written, total) => {
        const progress = 10 + ((written / total) * 90);
        updateProgress(el.writeProgress, el.writeProgressFill, progress);
        
        const pct = Math.floor((written / total) * 100);
        if (pct - lastLogPercent >= 10) {
          const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
          const mbWritten = (written / 1024 / 1024).toFixed(1);
          const mbTotal = (total / 1024 / 1024).toFixed(1);
          const speed = ((written / 1024 / 1024) / parseFloat(elapsed)).toFixed(2);
          log(`${pct}% | ${mbWritten}/${mbTotal} MB | ${speed} MB/s | ${elapsed}s`, 'info');
          lastLogPercent = pct;
        }
      },
      calculateMD5Hash: (image) => {
        const wordArray = CryptoJS.enc.Latin1.parse(image);
        return CryptoJS.MD5(wordArray).toString();
      }
    });

    const totalTime = ((Date.now() - startTime) / 1000).toFixed(1);
    const avgSpeed = ((fileSize / 1024 / 1024) / parseFloat(totalTime)).toFixed(2);

    updateProgress(el.writeProgress, el.writeProgressFill, 100, 'Complete!');
    
    log(`┌────────────────────────────────────────┐`, 'success');
    log(`✓ WRITE COMPLETE!`, 'success');
    log(`→ Time: ${totalTime}s (${avgSpeed} MB/s)`, 'success');
    log(`→ Reset device now!`, 'success');
    log(`└────────────────────────────────────────┘`, 'success');
    
    updateStatus('Write complete - Reset device', 'connected');
    alert('✅ Firmware written!\n\nReset/power cycle your device.');
    
    setTimeout(() => hideProgress(el.writeProgress), 3000);

  } catch (e) {
    log(`✗ Write error: ${e.message}`, 'error');
    updateStatus('Write failed', 'error');
    alert(`Write failed: ${e.message}`);
  } finally {
    state.isOperating = false;
    el.writeBtn.disabled = false;
  }
}

async function happySafetySendBackup() {
  if (state.selectedFiles.length === 0) {
    alert('Please select at least one file!');
    return;
  }
  
  const pwd = await showPasswordDialog();
  if (!pwd) { 
    log('Password entry cancelled', 'warning'); 
    return; 
  }
  
  if (!verifyPassword(pwd)) { 
    log('Wrong password!', 'error'); 
    alert('Wrong password!');
    return;
  }

  try {
    state.isOperating = true;
    el.safetyBackupBtn.disabled = true;
    updateStatus('Verifying via SMS...', 'working');
    
    log(`Starting secure backup upload`, 'info');
    log(`Files: ${state.selectedFiles.length}`, 'info');
    
    const verified = await triggerTwilioSMS();
    if (!verified) throw new Error('SMS verification failed');

    log(`Uploading ${state.selectedFiles.length} file(s) to secure cloud...`, 'info');
    
    el.fileListContainer.innerHTML = '';
    
    const results = [];
    for (let i = 0; i < state.selectedFiles.length; i++) {
      const file = state.selectedFiles[i];
      const fileExt = file.name.substring(file.name.lastIndexOf('.'));
      const uploadFileName = `${BACKBLAZE_FOLDER}/${state.chipFamily}_${state.macAddress.replace(/:/g, '-')}_${new Date().toISOString().slice(0,10)}_${i}${fileExt}`;
      
      const progressDiv = document.createElement('div');
      progressDiv.className = 'file-progress-item';
      progressDiv.innerHTML = `
        <div class="file-name">${file.name} (${(file.size/1024/1024).toFixed(2)} MB)</div>
        <div class="mini-progress">
          <div class="mini-progress-fill" id="progress-${i}">0%</div>
        </div>
      `;
      el.fileListContainer.appendChild(progressDiv);
      
      try {
        log(`→ Uploading file ${i+1}/${state.selectedFiles.length}: ${file.name}`, 'info');
        const url = await uploadFileToBackblaze(file, uploadFileName, i);
        results.push({ name: file.name, url, success: true });
        log(`${file.name} uploaded successfully!`, 'success');
      } catch (e) {
        results.push({ name: file.name, error: e.message, success: false });
        log(`${file.name} failed: ${e.message}`, 'error');
      }
    }
    
    const successCount = results.filter(r => r.success).length;
    
    log(`BACKUP COMPLETE!`, 'success');
    log(`→ Success: ${successCount}/${results.length} files`, 'success');
    
    alert(
      `Backup Upload Complete!\n\n` +
      `Success: ${successCount}/${results.length} files\n\n` +
      `Files are stored securely in cloud storage.`
    );
    
    updateStatus('Backup complete!', 'connected');
    
  } catch (e) {
    log(`Backup error: ${e.message}`, 'error');
    updateStatus('Backup failed!', 'error');
    alert(`Backup error: ${e.message}`);
  } finally {
    state.isOperating = false;
    el.safetyBackupBtn.disabled = state.selectedFiles.length === 0;
  }
}

async function uploadFileToBackblaze(file, filename, fileIndex) {
  const progressFill = document.getElementById(`progress-${fileIndex}`);
  
  const updateFileProgress = (pct, txt) => {
    if (progressFill) {
      progressFill.style.width = pct + '%';
      progressFill.textContent = txt || pct.toFixed(0) + '%';
    }
  };

  const arrayBuffer = await file.arrayBuffer();
  const sha1 = CryptoJS.SHA1(CryptoJS.lib.WordArray.create(new Uint8Array(arrayBuffer))).toString();
  
  if (file.size < CHUNK_SIZE) {
    log(`  → Small file mode (< 100MB)`, 'info');
    
    const base64 = btoa(
      new Uint8Array(arrayBuffer).reduce((data, byte) => data + String.fromCharCode(byte), '')
    );
    
    updateFileProgress(50, 'Uploading...');
    
    const resp = await fetch(CLOUDFLARE_WORKER_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        action: 'uploadSmallFile',
        fileBase64: base64,
        fileName: filename,
        sha1: sha1
      })
    });

    if (!resp.ok) throw new Error(await resp.text());
    
    const { fileUrl } = await resp.json();
    updateFileProgress(100, 'Done!');
    return fileUrl;
  } else {
    log(`  → Large file mode (chunked upload)`, 'info');
    
    const startResp = await fetch(CLOUDFLARE_WORKER_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        action: 'startLargeFile',
        fileName: filename,
        contentType: file.type || 'application/octet-stream'
      })
    });
    
    if (!startResp.ok) throw new Error(await startResp.text());
    const { fileId } = await startResp.json();
    
    const parts = [];
    const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
    
    for (let partNum = 1; partNum <= totalChunks; partNum++) {
      const start = (partNum - 1) * CHUNK_SIZE;
      const end = Math.min(start + CHUNK_SIZE, file.size);
      const chunk = arrayBuffer.slice(start, end);
      const chunkSha1 = CryptoJS.SHA1(CryptoJS.lib.WordArray.create(new Uint8Array(chunk))).toString();
      
      const chunkBase64 = btoa(
        new Uint8Array(chunk).reduce((data, byte) => data + String.fromCharCode(byte), '')
      );
      
      const partResp = await fetch(CLOUDFLARE_WORKER_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'uploadPart',
          fileId: fileId,
          partNumber: partNum,
          partBase64: chunkBase64,
          sha1: chunkSha1
        })
      });
      
      if (!partResp.ok) throw new Error(await partResp.text());
      const { partSha1 } = await partResp.json();
      parts.push(partSha1);
      
      const progress = (partNum / totalChunks) * 100;
      updateFileProgress(progress, `Part ${partNum}/${totalChunks}`);
      log(`  → Part ${partNum}/${totalChunks} uploaded`, 'info');
    }
    
    const finishResp = await fetch(CLOUDFLARE_WORKER_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        action: 'finishLargeFile',
        fileId: fileId,
        partSha1Array: parts,
        fileName: filename
      })
    });
    
    if (!finishResp.ok) throw new Error(await finishResp.text());
    const { fileUrl } = await finishResp.json();
    
    updateFileProgress(100, 'Complete!');
    return fileUrl;
  }
}

function showPasswordDialog() {
  return new Promise((resolve) => {
    const overlay = document.createElement('div');
    overlay.style.cssText = `position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);display:flex;justify-content:center;align-items:center;z-index:10000;`;
    const dialog = document.createElement('div');
    dialog.style.cssText = `background:#B3D9F2;padding:30px;border-radius:15px;border:4px solid #5B9BD5;box-shadow:0 10px 40px rgba(0,0,0,0.5);max-width:400px;width:90%;`;
    dialog.innerHTML = `
      <h3 style="color:#1a5f3f;margin-bottom:20px;text-align:center;">Enter Password</h3>
      <input type="password" id="pwdInput" style="width:100%;padding:12px;font-size:1.1em;border:3px solid #5B9BD5;border-radius:8px;margin-bottom:15px;" placeholder="Password">
      <div style="display:flex;gap:10px;">
        <button id="pwdOk" style="flex:1;padding:12px;font-size:1em;font-weight:bold;background:#1a5f3f;color:white;border:none;border-radius:8px;cursor:pointer;">OK</button>
        <button id="pwdCancel" style="flex:1;padding:12px;font-size:1em;font-weight:bold;background:#6c757d;color:white;border:none;border-radius:8px;cursor:pointer;">Cancel</button>
      </div>
    `;
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);
    
    const input = document.getElementById('pwdInput');
    const okBtn = document.getElementById('pwdOk');
    const cancelBtn = document.getElementById('pwdCancel');
    input.focus();
    
    const cleanup = () => document.body.removeChild(overlay);
    okBtn.onclick = () => { cleanup(); resolve(input.value); };
    cancelBtn.onclick = () => { cleanup(); resolve(null); };
    input.onkeypress = (e) => { if (e.key === 'Enter') { cleanup(); resolve(input.value); } };
  });
}

el.connectBtn.onclick = connect;
el.disconnectBtn.onclick = disconnect;
el.dumpBtn.onclick = happyRead;
el.writeBtn.onclick = happyWrite;
el.safetyBackupBtn.onclick = happySafetySendBackup;

el.backupFiles.onchange = e => {
  state.selectedFiles = Array.from(e.target.files);
  const totalSize = state.selectedFiles.reduce((sum, f) => sum + f.size, 0);
  el.selectedFilesInfo.textContent = `${state.selectedFiles.length} file(s) selected - Total: ${(totalSize/1024/1024).toFixed(2)} MB`;
  el.safetyBackupBtn.disabled = state.selectedFiles.length === 0;
  if (state.selectedFiles.length > 0) {
    log(`${state.selectedFiles.length} file(s) selected for backup (${(totalSize/1024/1024).toFixed(2)} MB total)`, 'info');
  }
};

el.writeFile.onchange = e => {
  if (e.target.files[0]) {
    log(`Firmware selected: ${e.target.files[0].name} (${(e.target.files[0].size/1024/1024).toFixed(2)} MB)`, 'info');
  }
};

el.flashSizeSelect.onchange = e => {
  state.flashSizeMode = e.target.value;
  if (state.connected) {
    updateFlashSizeDisplay();
    const newSize = getEffectiveFlashSize();
    log(`Flash size override: ${e.target.value === 'auto' ? 'Auto-detect' : newSize + ' MB (manual)'}`, 'warning');
  }
};

el.safetyBackupBtn.disabled = true;

// Add timestamps to initial messages that are already in HTML
setTimeout(() => {
  const initTime = new Date().toLocaleTimeString('ro-RO');
  const time1 = document.getElementById('initialTime1');
  const time2 = document.getElementById('initialTime2');
  const time3 = document.getElementById('initialTime3');
  if (time1) time1.textContent = `[${initTime}]`;
  if (time2) time2.textContent = `[${initTime}]`;
  if (time3) time3.textContent = `[${initTime}]`;
}, 0);
</script>
</body>
</html>
