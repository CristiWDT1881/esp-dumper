// === HAPPY WRITE ===
        async function happyWrite() {
            if (!state.connected || state.isOperating) return;
            
            const files = el.writeFile.files;
            if (!files || files.length === 0) {
                alert('Please select at least one .bin file!');
                return;
            }

            const eraseChoice = confirm('Erase entire flash before writing?\n\nOK = Full Erase (recommended)\nCancel = Write only (faster, risky)');
            
            state.isOperating = true;
            el.writeBtn.disabled = true;

            try {
                log(`Writing ${files.length} file(s)...`, 'info');
                updateStatus('Writing...', 'working');

                if (eraseChoice) {
                    log('Erasing flash...', 'warning');
                    await state.esploader.eraseFlash();
                    log('Flash erased', 'success');
                }

                for (let fileIdx = 0; fileIdx < files.length; fileIdx++) {
                    const file = files[fileIdx];
                    log(`Writing ${file.name}...`, 'info');
                    
                    const data = await file.arrayBuffer();
                    const offset = 0x0; // Write la adresa 0x0 (bootloader)
                    
                    await state.esploader.writeFlash({
                        fileArray: [{data: data, address: offset}],
                        flashSize: 'keep',
                        eraseAll: false,
                        compress: true,
                        reportProgress: (idx, written, total) => {
                            const pct = Math.floor((written / total) * 100);
                            updateProgress(el.writeProgress, el.writeProgressFill, pct, `${pct}%`);
                        }
                    });

                    log(`${file.name} written successfully`, 'success');
                }

                updateProgress(el.writeProgress, el.writeProgressFill, 100, 'Done!');
                log('All files written successfully!', 'success');
                updateStatus('Write complete!', 'connected');
                
                setTimeout(() => hideProgress(el.writeProgress), 3000);
                
                const reboot = confirm('Flash written successfully!\n\nReboot device now?');
                if (reboot) {
                    await state.esploader.hardReset();
                    log('Device rebooted', 'success');
                }
                
            } catch (e) {
                log(`Write error: ${e.message}`, 'error');
                updateStatus('Write failed', 'error');
                alert(`Write failed: ${e.message}\n\nTry:\n- Lower baud rate\n- Full erase option\n- Check cable connection`);
            } finally {
                state.isOperating = false;
                el.writeBtn.disabled = false;
            }
        }

        // === GITHUB BACKUP ===
        async function backupGitHub() {
            if (!state.lastDumpData || !state.lastDumpFilename) {
                alert('No dump available! Do HAPPY READ first.');
                return;
            }

            const pwd = prompt('Enter GitHub backup password:');
            if (pwd !== GITHUB.password) {
                alert('Wrong password!');
                return;
            }

            state.isOperating = true;
            el.githubBackupBtn.disabled = true;

            try {
                log('Starting GitHub backup...', 'info');
                updateStatus('Uploading to GitHub...', 'working');
                updateProgress(el.githubProgress, el.githubProgressFill, 10, 'Preparing...');

                // Convert to base64
                const base64 = btoa(String.fromCharCode(...new Uint8Array(state.lastDumpData)));
                updateProgress(el.githubProgress, el.githubProgressFill, 30, 'Encoding...');

                const path = `${GITHUB.folder}/${state.lastDumpFilename}`;
                const url = `https://api.github.com/repos/${GITHUB.repo}/contents/${path}`;
                
                updateProgress(el.githubProgress, el.githubProgressFill, 50, 'Uploading...');

                const response = await fetch(url, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${GITHUB.token}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        message: `Backup: ${state.lastDumpFilename}`,
                        content: base64,
                        branch: 'main'
                    })
                });

                updateProgress(el.githubProgress, el.githubProgressFill, 90, 'Finalizing...');

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.message || 'Upload failed');
                }

                const result = await response.json();
                updateProgress(el.githubProgress, el.githubProgressFill, 100, 'Done!');
                log(`Backed up to: ${result.content.html_url}`, 'success');
                updateStatus('Backup complete!', 'connected');
                
                setTimeout(() => hideProgress(el.githubProgress), 3000);
                alert(`Backup successful!\n\nFile: ${state.lastDumpFilename}\n\nView on GitHub: ${result.content.html_url}`);

            } catch (e) {
                log(`GitHub backup error: ${e.message}`, 'error');
                updateStatus('Backup failed', 'error');
                alert(`GitHub backup failed: ${e.message}\n\nCheck:\n- Internet connection\n- GitHub token validity\n- Repository permissions`);
            } finally {
                state.isOperating = false;
                el.githubBackupBtn.disabled = false;
            }
        }

