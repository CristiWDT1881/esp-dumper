

async function happyRead(resume = false) {
            if (!state.connected || state.isOperating) return;
            state.isOperating = true;
            el.dumpBtn.disabled = true;
            el.resumeBtn.disabled = true;

            try {
                log(resume ? 'Resuming dump...' : 'Starting BIT-PERFECT Flash Clone...', 'info');
                updateStatus('Reading...', 'working');

                // ===== DETECTARE DIMENSIUNE REALĂ FLASH =====
                log('Detecting real flash size...', 'info');
                let realFlashSize = 0;
                try {
                    const flashId = await state.esploader.flashId();
                    log(`Flash ID: 0x${flashId.toString(16)}`, 'info');
                    
                    // Detectare automată din chip
                    if (state.chip && state.chip.getFlashSize) {
                        realFlashSize = await state.chip.getFlashSize();
                    }
                } catch (e) {
                    log(`Auto-detection failed, using dropdown value`, 'warning');
                }

                // Fallback la valoarea din dropdown
                if (!realFlashSize || realFlashSize === 0) {
                    realFlashSize = parseInt(el.flashSize.value) * 1024 * 1024;
                }

                const flashBytes = realFlashSize;
                log(`Flash size: ${(flashBytes/1024/1024).toFixed(2)} MB`, 'success');

                // ===== CHUNK SIZE OPTIM =====
                // Chunk mai mic = mai sigur, mai lent
                // ESP32-S3 este sensibil, folosim 1KB
                const chunk = 1024; 
                let offset = resume ? state.resumeOffset : 0;
                const data = new Uint8Array(flashBytes);

                // Dacă e resume, încarcă datele existente
                if (resume && state.resumeFile) {
                    const reader = new FileReader();
                    await new Promise((res, rej) => {
                        reader.onload = () => { 
                            data.set(new Uint8Array(reader.result), 0); 
                            res(); 
                        };
                        reader.onerror = rej;
                        reader.readAsArrayBuffer(state.resumeFile);
                    });
                    log(`Resumed from ${(offset/1024/1024).toFixed(2)} MB`, 'info');
                }

                const total = Math.ceil((flashBytes - offset) / chunk);
                let read = 0;
                let lastLog = 0;
                let consecutiveErrors = 0;
                const MAX_CONSECUTIVE_ERRORS = 10;

                log(`Reading ${(flashBytes/1024/1024).toFixed(2)} MB in ${total} chunks of ${chunk} bytes`, 'info');
                log('This will take time but ensures perfect clone...', 'warning');

                // ===== CITIRE BIT-PERFECT =====
                for (let i = 0; i < total; i++) {
                    const addr = offset + i * chunk;
                    const size = Math.min(chunk, flashBytes - addr);
                    let block = null;
                    let readOk = false;

                    // Maximum 3 retry-uri per chunk
                    for (let attempt = 0; attempt < 3; attempt++) {
                        try {
                            // Sincronizare înainte de citire
                            if (attempt > 0) {
                                await state.esploader.sync();
                                await new Promise(r => setTimeout(r, 100));
                            }

                            // Citire chunk
                            block = await state.esploader.readFlash(addr, size);
                            
                            // VERIFICARE CRITICĂ: dimensiune exactă
                            if (!block || block.byteLength !== size) {
                                throw new Error(`Size mismatch: expected ${size}, got ${block?.byteLength || 0}`);
                            }

                            // VERIFICARE: calculează checksum pentru validare
                            const blockArray = new Uint8Array(block);
                            let checksum = 0;
                            for (let j = 0; j < blockArray.length; j++) {
                                checksum = (checksum + blockArray[j]) & 0xFF;
                            }

                            // Succes!
                            readOk = true;
                            consecutiveErrors = 0;
                            
                            // Scrie în buffer
                            data.set(blockArray, addr);
                            break;

                        } catch (e) {
                            if (attempt === 2) {
                                consecutiveErrors++;
                                log(`FAILED at 0x${addr.toString(16)} after 3 attempts: ${e.message}`, 'error');
                                
                                if (consecutiveErrors >= MAX_CONSECUTIVE_ERRORS) {
                                    throw new Error(`Too many consecutive errors (${consecutiveErrors}). Check connection!`);
                                }
                                
                                // Întreabă user dacă vrea să continue
                                const continueRead = confirm(
                                    `Read error at address 0x${addr.toString(16)}\n\n` +
                                    `Progress: ${((addr/flashBytes)*100).toFixed(1)}%\n\n` +
                                    `Continue reading? (errors will be filled with 0xFF)`
                                );
                                
                                if (!continueRead) {
                                    throw new Error('Read cancelled by user');
                                }
                                
                                // Fill cu 0xFF pentru zona eronată
                                for (let j = 0; j < size; j++) {
                                    data[addr + j] = 0xFF;
                                }
                                readOk = true;
                                break;
                            }
                            
                            await new Promise(r => setTimeout(r, 150 * (attempt + 1)));
                        }
                    }

                    if (!readOk) continue;

                    read += size;
                    const pct = Math.floor((offset + read) / flashBytes * 100);
                    updateProgress(el.dumpProgress, el.dumpProgressFill, pct, `${pct}%`);
                    
                    // Log la fiecare 2%
                    if (pct >= lastLog + 2) {
                        const mbRead = ((offset + read) / 1024 / 1024).toFixed(2);
                        const speed = (read / 1024).toFixed(0);
                        log(`${pct}% - ${mbRead} MB read (${speed} KB)`, 'info');
                        lastLog = pct;
                    }

                    // Pauză la fiecare 100 chunks pentru ESP32-S3
                    if (i % 100 === 0 && i > 0) {
                        await new Promise(r => setTimeout(r, 50));
                    }
                }

                // ===== ANALIZĂ FINALĂ =====
                let totalDataBytes = 0;
                let totalEmptyBytes = 0;
                const SAMPLE_SIZE = Math.min(256 * 1024, data.length); // Primii 256KB
                
                for (let i = 0; i < data.length; i++) {
                    if (data[i] !== 0xFF) totalDataBytes++;
                    else totalEmptyBytes++;
                }

                // Verifică header ESP32
                const hasValidHeader = data[0] === 0xE9;
                const dataPct = ((totalDataBytes / flashBytes) * 100).toFixed(2);

                log(`=== BIT-PERFECT CLONE COMPLETE ===`, 'success');
                log(`Total: ${(flashBytes/1024/1024).toFixed(2)} MB`, 'info');
                log(`Data: ${(totalDataBytes/1024/1024).toFixed(2)} MB (${dataPct}%)`, 'success');
                log(`Empty: ${(totalEmptyBytes/1024/1024).toFixed(2)} MB`, 'info');
                log(`Valid Header: ${hasValidHeader ? 'YES ✓' : 'NO ✗'}`, hasValidHeader ? 'success' : 'warning');

                // Warning dacă pare empty
                if (dataPct < 1) {
                    log('⚠️ WARNING: Flash appears mostly empty!', 'warning');
                    const proceed = confirm(
                        `Flash contains very little data (${dataPct}%)!\n\n` +
                        `This might indicate:\n` +
                        `- Empty/new device\n` +
                        `- Read error\n` +
                        `- Wrong flash size\n\n` +
                        `Save anyway?`
                    );
                    if (!proceed) {
                        state.isOperating = false;
                        el.dumpBtn.disabled = false;
                        el.resumeBtn.disabled = false;
                        return;
                    }
                }

                // ===== SALVARE =====
                const ts = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                const chipName = state.chip?.CHIP_NAME || el.deviceType.value;
                const name = `${chipName}_CLONE_${(flashBytes/1024/1024)}MB_${ts}.bin`;
                
                const blob = new Blob([data]);
                log(`Creating file: ${name}`, 'info');
                log(`File size: ${(blob.size/1024/1024).toFixed(2)} MB (${blob.size} bytes)`, 'info');
                
                // Verificare finală
                if (blob.size !== flashBytes) {
                    log(`⚠️ Size warning: Expected ${flashBytes}, got ${blob.size}`, 'warning');
                }
                
                saveAs(blob, name);
                state.lastDumpData = data;
                state.lastDumpFilename = name;
                
                updateProgress(el.dumpProgress, el.dumpProgressFill, 100, 'DONE ✓');
                log(`✓ Saved: ${name}`, 'success');
                log(`Clone ready for writing to another device!`, 'success');
                updateStatus('Clone complete!', 'connected');
                
                setTimeout(() => hideProgress(el.dumpProgress), 3000);
                
            } catch (e) {
                log(`ERROR: ${e.message}`, 'error');
                updateStatus('Read failed', 'error');
                alert(
                    `Read failed: ${e.message}\n\n` +
                    `Solutions:\n` +
                    `1. Lower baud rate (460800 or 230400)\n` +
                    `2. Use high-quality USB cable\n` +
                    `3. Reconnect device and retry\n` +
                    `4. Check flash size setting\n` +
                    `5. Try different USB port`
                );
            } finally {
                state.isOperating = false;
                el.dumpBtn.disabled = false;
                el.resumeBtn.disabled = false;
            }
        }
