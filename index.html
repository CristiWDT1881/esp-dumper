<!DOCTYPE html>
<html lang="ro">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ESP32 Flash Dumper & Writer</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
font-family: 'Segoe UI', Arial, sans-serif;
background-color: #1a5f3f;
min-height: 100vh;
padding: 20px;
display: flex;
flex-direction: column;
align-items: center;
}
.header-images {
display: flex;
justify-content: space-between;
align-items: flex-start;
width: 100%;
max-width: 700px;
margin-bottom: 40px;
}
.header-images img {
max-width: 180px;
height: auto;
border-radius: 10px;
box-shadow: 0 4px 15px rgba(0,0,0,0.3);
border: 4px solid #5B9BD5;
}
.container { max-width: 700px; width: 100%; }
h1 {
color: #FFD700;
font-size: 2.5em;
text-align: center;
margin: 20px 0;
text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
}
.section {
background: #B3D9F2;
border-radius: 15px;
padding: 20px;
margin-bottom: 15px;
box-shadow: 0 8px 30px rgba(0,0,0,0.3);
border: 4px solid #5B9BD5;
}
.section.first-box {
display: flex;
gap: 20px;
align-items: flex-start;
padding: 10px 20px;
}
.section-content { flex: 1; }
.signature-img {
width: 130px;
height: auto;
border-radius: 10px;
box-shadow: 0 4px 15px rgba(0,0,0,0.2);
border: 4px solid #5B9BD5;
}
.section h2 { color: #1a5f3f; font-size: 1.3em; margin-bottom: 10px; }
.section p { color: #000; font-size: 0.95em; margin-bottom: 5px; }
.control-group { margin-bottom: 10px; }
.control-group label { color: #1a5f3f; font-weight: bold; display: block; margin-bottom: 5px; }
select, input[type="file"] {
width: 100%;
padding: 8px;
border: 3px solid #5B9BD5;
border-radius: 8px;
background: white;
}
.button-group {
display: flex;
gap: 10px;
margin-top: 10px;
flex-wrap: wrap;
}
button {
flex: 1;
min-width: 180px;
padding: 12px;
font-size: 1.1em;
font-weight: bold;
border: none;
border-radius: 12px;
cursor: pointer;
transition: all 0.3s;
box-shadow: 0 6px 20px rgba(0,0,0,0.3);
}
.btn-connect { background: #1a5f3f; color: white; }
.btn-connect:hover { background: #145030; transform: translateY(-2px); }
.btn-disconnect { background: #6c757d; color: white; }
.btn-read, .btn-write { background: #5B9BD5; color: #000; }
.btn-read:hover, .btn-write:hover { background: #FFD700; transform: translateY(-2px); }
button:disabled { opacity: 0.5; cursor: not-allowed; transform: none !important; }
.tab-buttons {
display: flex;
gap: 10px;
margin-bottom: 15px;
}
.tab-btn {
flex: 1;
padding: 10px;
background: #5B9BD5;
color: white;
border: none;
border-radius: 8px;
cursor: pointer;
font-weight: bold;
transition: all 0.3s;
}
.tab-btn.active { background: #1a5f3f; }
.tab-content { display: none; }
.tab-content.active { display: block; }
.status {
background: white;
padding: 10px;
border-radius: 8px;
margin-bottom: 10px;
border: 3px solid #5B9BD5;
font-weight: 500;
}
.status.connected { border-color: #1a5f3f; background: #d4edda; }
.status.working { border-color: #FFD700; background: #fff3cd; }
.status.error { border-color: #dc3545; background: #f8d7da; }
.info-box {
background: white;
padding: 10px;
border-radius: 8px;
margin-top: 10px;
border: 3px solid #5B9BD5;
font-size: 0.9em;
}
.info-box strong { color: #1a5f3f; }
.progress-bar {
width: 100%;
height: 30px;
background: white;
border-radius: 8px;
border: 3px solid #5B9BD5;
overflow: hidden;
margin: 10px 0;
display: none;
}
.progress-bar.active { display: block; }
.progress-fill {
height: 100%;
background: linear-gradient(90deg, #1a5f3f, #5B9BD5);
width: 0%;
transition: width 0.3s;
display: flex;
align-items: center;
justify-content: center;
color: white;
font-weight: bold;
}
.log-container {
background: #1e1e1e;
color: #00ff00;
padding: 15px;
border-radius: 8px;
max-height: 400px;
overflow-y: auto;
font-family: 'Courier New', monospace;
font-size: 0.9em;
line-height: 1.6;
}
.log-entry { margin-bottom: 3px; }
.log-entry.error { color: #ff6b6b; }
.log-entry.success { color: #51cf66; }
.log-entry.warning { color: #ffd43b; }
.log-entry.info { color: #74c0fc; }
.radio-links {
display: flex;
justify-content: space-around;
align-items: center;
gap: 30px;
flex-wrap: wrap;
}
.radio-link {
display: flex;
flex-direction: column;
align-items: center;
text-decoration: none;
transition: transform 0.3s;
}
.radio-link:hover { transform: scale(1.1); }
.radio-link img {
width: 120px;
height: 120px;
border-radius: 15px;
box-shadow: 0 4px 15px rgba(0,0,0,0.2);
margin-bottom: 10px;
border: 4px solid #5B9BD5;
}
.radio-link span {
color: #000;
font-weight: bold;
font-size: 1.1em;
}
@media (max-width: 768px) {
.header-images { flex-direction: column; align-items: center; gap: 15px; }
h1 { font-size: 2em; }
}
</style>
</head>
<body>
<div class="header-images">
<img src="./palatiasi.png" alt="Palatul Culturii" onerror="this.style.display='none'">
<img src="./logo.png" alt="Logo" onerror="this.style.display='none'">
</div>
<div class="container">
<h1>ESP32 Flash Dumper & Writer</h1>
<div class="section first-box">
<div class="section-content">
<h2>Connect Device</h2>
<div id="status" class="status">Status: Disconnected</div>
<div id="deviceInfo" class="info-box" style="display: none;">
<strong>Chip:</strong> <span id="chipType">-</span><br>
<strong>Flash Size:</strong> <span id="flashSize">-</span><br>
<strong>MAC Address:</strong> <span id="macAddress">-</span>
</div>
<div class="control-group">
<label>Flash Size (MB):</label>
<select id="flashSizeSelect">
<option value="auto">Auto Detect</option>
<option value="1">1</option>
<option value="2">2</option>
<option value="4">4</option>
<option value="8">8</option>
<option value="16">16</option>
<option value="32">32</option>
<option value="64">64</option>
</select>
</div>
<div class="button-group">
<button id="connectBtn" class="btn-connect">CONNECT</button>
<button id="disconnectBtn" class="btn-disconnect" disabled>DISCONNECT</button>
</div>
</div>
<img src="./semnatura.png" alt="Signature" class="signature-img" onerror="this.style.display='none'">
</div>
<div class="section">
<h2>Happy Read - Dump Flash</h2>
<p><strong>1.</strong> Connect device via USB</p>
<p><strong>2.</strong> Click HAPPY READ to dump entire flash (including bootloader)</p>
<p><strong>3.</strong> Complete flash image will be saved to Downloads</p>
<div class="button-group">
<button id="dumpBtn" class="btn-read" disabled>HAPPY READ</button>
</div>
<div id="dumpProgress" class="progress-bar">
<div id="dumpProgressFill" class="progress-fill">0%</div>
</div>
</div>
<div class="section">
<h2>Backup Options</h2>
<p>Choose tab for backup type.</p>
<div class="tab-buttons">
<button class="tab-btn active" onclick="switchTab('github-dump')">GitHub Dump Backup</button>
<button class="tab-btn" onclick="switchTab('send-file')">Send to Backblaze (Uploads)</button>
</div>
<div id="github-dump-tab" class="tab-content active">
<p><strong>1.</strong> First do HAPPY READ to create dump</p>
<p><strong>2.</strong> Click button below to backup to GitHub</p>
<p><strong>3.</strong> Enter password when prompted</p>
<div class="button-group">
<button id="githubBackupBtn" class="btn-write" disabled>HAPPY BACKUP DUMP ON GITHUB</button>
</div>
<div id="githubProgress" class="progress-bar">
<div id="githubProgressFill" class="progress-fill">0%</div>
</div>
</div>
<div id="send-file-tab" class="tab-content">
<p><strong>1.</strong> Select any file (.bin or ZIP)</p>
<p><strong>2.</strong> Upload to <strong>githubwdt81 / Uploads</strong> (private)</p>
<p><strong>3.</strong> Confirm GitHub SMS code</p>
<div class="control-group">
<label>Select File:</label>
<input type="file" id="backupFile" accept=".bin,.zip">
</div>
<div class="button-group">
<button id="sendFileBtn" class="btn-write" disabled>SEND TO BACKBLAZE</button>
</div>
<div id="sendProgress" class="progress-bar">
<div id="sendProgressFill" class="progress-fill">0%</div>
</div>
</div>
</div>
<div class="section">
<h2>Happy Write - Write Flash</h2>
<p><strong>1.</strong> Select firmware file (.bin) - full flash dump</p>
<p><strong>2.</strong> Click HAPPY WRITE</p>
<p><strong>3.</strong> System will verify compatibility (±25%) before writing</p>
<div class="control-group">
<label>Select Firmware File:</label>
<input type="file" id="writeFile" accept=".bin">
</div>
<div class="button-group">
<button id="writeBtn" class="btn-write" disabled>HAPPY WRITE</button>
</div>
<div id="writeProgress" class="progress-bar">
<div id="writeProgressFill" class="progress-fill">0%</div>
</div>
</div>
<div class="section">
<h2>Operation Log</h2>
<div id="logContainer" class="log-container">
<div class="log-entry info">System initialized. Connect device to start...</div>
</div>
</div>
<div class="section">
<h2>Radio Live</h2>
<div class="radio-links">
<a href="https://www.radioromaniacultural.ro/live/" target="_blank" class="radio-link">
<img src="./logocultural.svg" alt="Radio România Cultural" onerror="this.style.display='none'">
<span>Cultural</span>
</a>
<a href="http://player.radioiasi.ro/live-radio-iasi.html" target="_blank" class="radio-link">
<img src="./logoriasi.svg" alt="Radio Iași" onerror="this.style.display='none'">
<span>Radio Iași</span>
</a>
</div>
</div>
</div>

<script type="module">
import { ESPLoader, Transport } from 'https://unpkg.com/esptool-js@0.4.5/bundle.js';

const state = {
  port: null, esploader: null, transport: null, chip: null,
  connected: false, isOperating: false,
  lastDumpData: null, lastDumpFilename: null,
  detectedFlashSize: 0, detectedFlashBytes: 0,
  chipType: '', macAddress: '', flashSizeMode: 'auto',
  lastSelectedFile: null,
  b2Config: {
    accountId: '005334a4b31a9360000000001',
    appKey: 'K005zhQGlhc5vZ1Rcn8+MgZbNnaF4CM',  // ← AICI PUI CHEIA TA K00...
    bucketId: '1303149a14db53119aa90316',
    bucketName: 'githubwdt81',
    privateFolder: 'Uploads',
    apiUrl: 'https://api.backblazeb2.com'
  }
};

const GITHUB = {
  token: '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',
  repo: 'CristiWDT1881/esp-dumper',
  folder: 'happydumps',
  password: 'wdt81boom'
};

const el = {
  status: document.getElementById('status'),
  connectBtn: document.getElementById('connectBtn'),
  disconnectBtn: document.getElementById('disconnectBtn'),
  dumpBtn: document.getElementById('dumpBtn'),
  writeBtn: document.getElementById('writeBtn'),
  githubBackupBtn: document.getElementById('githubBackupBtn'),
  sendFileBtn: document.getElementById('sendFileBtn'),
  logContainer: document.getElementById('logContainer'),
  dumpProgress: document.getElementById('dumpProgress'),
  dumpProgressFill: document.getElementById('dumpProgressFill'),
  writeProgress: document.getElementById('writeProgress'),
  writeProgressFill: document.getElementById('writeProgressFill'),
  githubProgress: document.getElementById('githubProgress'),
  githubProgressFill: document.getElementById('githubProgressFill'),
  sendProgress: document.getElementById('sendProgress'),
  sendProgressFill: document.getElementById('sendProgressFill'),
  writeFile: document.getElementById('writeFile'),
  backupFile: document.getElementById('backupFile'),
  deviceInfo: document.getElementById('deviceInfo'),
  chipType: document.getElementById('chipType'),
  flashSize: document.getElementById('flashSize'),
  macAddress: document.getElementById('macAddress'),
  flashSizeSelect: document.getElementById('flashSizeSelect')
};

function log(msg, type = 'info') {
  const time = new Date().toLocaleTimeString('ro-RO');
  const entry = document.createElement('div');
  entry.className = `log-entry ${type}`;
  entry.textContent = `[${time}] ${msg}`;
  el.logContainer.appendChild(entry);
  el.logContainer.scrollTop = el.logContainer.scrollHeight;
}

function updateStatus(msg, type = '') {
  el.status.textContent = msg;
  el.status.className = `status ${type}`;
}

function updateProgress(bar, fill, pct, txt) {
  bar.classList.add('active');
  fill.style.width = pct + '%';
  fill.textContent = txt || pct + '%';
}

function hideProgress(bar) { bar.classList.remove('active'); }

window.switchTab = function(tabName) {
  document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
  document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
  document.getElementById(tabName + '-tab').classList.add('active');
  event.target.classList.add('active');
};

const term = {
  lastOutput: '',
  clean: () => { term.lastOutput = ''; },
  writeLine: (t) => { log(t); term.lastOutput += t + '\n'; },
  write: (t) => { log(t); term.lastOutput += t; }
};

// === FUNCȚII DIN INDEX (4).HTML (100% FUNCȚIONALE) ===
async function detectFlashSize() {
  try {
    log('Detecting flash size...', 'info');
    term.clean();
    try {
      const stubFlashSize = await state.esploader.getFlashSize();
      if (stubFlashSize && stubFlashSize > 0) {
        let detectedMB = stubFlashSize < 1024 * 1024 ? stubFlashSize / 1024 : stubFlashSize / (1024 * 1024);
        state.detectedFlashSize = detectedMB;
        state.detectedFlashBytes = detectedMB * 1024 * 1024;
        log(`Detected from stub: ${state.detectedFlashSize.toFixed(2)} MB`, 'success');
        return true;
      }
    } catch (e) { log('Stub getFlashSize failed, trying output parsing...', 'info'); }
    const flashSizeMatch = term.lastOutput.match(/Detected flash size:\s*(\d+)MB/i);
    if (flashSizeMatch) {
      const size = parseInt(flashSizeMatch[1], 10);
      state.detectedFlashSize = size;
      state.detectedFlashBytes = size * 1024 * 1024;
      log(`Detected from output: ${size} MB`, 'success');
      return true;
    }
    try {
      const flashId = await state.esploader.flashId();
      if (flashId && flashId !== 0xFFFFFF && flashId !== 0) {
        const sizeCode = (flashId & 0xFF00) >> 8;
        const map = {0x14:1,0x15:2,0x16:4,0x17:8,0x18:16,0x19:32,0x1A:64,0x20:16,0x21:32,0x22:64};
        if (map[sizeCode]) {
          state.detectedFlashSize = map[sizeCode];
          state.detectedFlashBytes = state.detectedFlashSize * 1024 * 1024;
          log(`Detected from FlashID: ${state.detectedFlashSize} MB`, 'success');
          return true;
        }
      }
    } catch (e) { log('FlashID not supported (ESP32-S3)', 'info'); }
    log('DEFAULTING TO 4MB', 'warning');
    state.detectedFlashSize = 4;
    state.detectedFlashBytes = 4 * 1024 * 1024;
    return false;
  } catch (e) {
    log(`Error: ${e.message}`, 'error');
    state.detectedFlashSize = 4;
    state.detectedFlashBytes = 4 * 1024 * 1024;
    return false;
  }
}

function getEffectiveFlashBytes() { return state.flashSizeMode === 'auto' ? state.detectedFlashBytes : parseInt(state.flashSizeMode, 10) * 1024 * 1024; }
function getEffectiveFlashSize() { return state.flashSizeMode === 'auto' ? state.detectedFlashSize : parseInt(state.flashSizeMode, 10); }
function updateFlashSizeDisplay() {
  const size = getEffectiveFlashSize();
  const mode = state.flashSizeMode === 'auto' ? `(detected: ${state.detectedFlashSize.toFixed(2)} MB)` : '(manual)';
  el.flashSize.textContent = `${size} MB ${mode}`;
}

async function connect() {
  try {
    if (!('serial' in navigator)) { alert('Web Serial API not supported!'); return; }
    if (state.transport) { try { await state.transport.disconnect(); } catch(e){} await new Promise(r=>setTimeout(r,300)); }
    updateStatus('Connecting...', 'working');
    log('Requesting port...', 'info');
    state.port = await navigator.serial.requestPort();
    state.transport = new Transport(state.port, true);
    state.esploader = new ESPLoader({ transport: state.transport, baudrate: 115200, romBaudrate: 115200, terminal: term, enableTracing: false });
    let retries = 3, lastError;
    while (retries-- > 0) { try { state.chip = await state.esploader.main(); break; } catch(e){ lastError = e; if(retries>0) await new Promise(r=>setTimeout(r,1000)); } }
    if (!state.chip) throw lastError;
    state.connected = true; state.chipType = state.chip?.CHIP_NAME || 'ESP32';
    log(`Connected: ${state.chipType}`, 'success');
    const macMatch = term.lastOutput.match(/MAC:\s*([0-9a-fA-F:]{17})/i);
    state.macAddress = macMatch ? macMatch[1].toUpperCase() : 'Unknown';
    log(`MAC: ${state.macAddress}`, 'info');
    await detectFlashSize();
    el.chipType.textContent = state.chipType;
    updateFlashSizeDisplay();
    el.macAddress.textContent = state.macAddress;
    el.deviceInfo.style.display = 'block';
    updateStatus(`${state.chipType} - ${getEffectiveFlashSize()}MB`, 'connected');
    el.connectBtn.disabled = el.dumpBtn.disabled = el.writeBtn.disabled = el.githubBackupBtn.disabled = false;
    el.disconnectBtn.disabled = false;
  } catch (e) {
    log(`Error: ${e.message}`, 'error');
    updateStatus('Failed', 'error');
    try { if(state.transport) await state.transport.disconnect(); if(state.port) await state.port.close(); } catch(e){}
    state.port = null; state.transport = null; state.esploader = null; state.connected = false;
  }
}

async function disconnect() {
  try {
    log('Disconnecting...', 'info');
    if (state.transport) await state.transport.disconnect();
    if (state.port) await state.port.close();
    state.port = null; state.esploader = null; state.transport = null; state.chip = null;
    state.connected = false; state.chipType = ''; state.macAddress = '';
    el.deviceInfo.style.display = 'none';
    updateStatus('Disconnected', '');
    log('Disconnected', 'success');
    el.connectBtn.disabled = false; el.disconnectBtn.disabled = el.dumpBtn.disabled = el.writeBtn.disabled = el.githubBackupBtn.disabled = true;
  } catch (e) { log(`Error: ${e.message}`, 'error'); }
}

async function happyRead() {
  if (!state.connected || state.isOperating) return;
  try {
    state.isOperating = true;
    el.dumpBtn.disabled = el.writeBtn.disabled = el.githubBackupBtn.disabled = true;
    log('Starting Happy Read...', 'info');
    updateStatus('Reading...', 'working');
    const bytes = getEffectiveFlashBytes();
    const data = new Uint8Array(bytes);
    const chunk = 4096;
    for (let i = 0; i < bytes; i += chunk) {
      const block = await state.esploader.readFlash(i, Math.min(chunk, bytes - i));
      data.set(new Uint8Array(block), i);
      const pct = Math.floor((i / bytes) * 100);
      updateProgress(el.dumpProgress, el.dumpProgressFill, pct, `${pct}%`);
    }
    const ts = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
    const mac = state.macAddress.replace(/:/g, '-').toLowerCase();
    const filename = `${state.chipType}_${mac}_${getEffectiveFlashSize()}MB_${ts}.bin`;
    saveAs(new Blob([data]), filename);
    state.lastDumpData = data; state.lastDumpFilename = filename;
    updateProgress(el.dumpProgress, el.dumpProgressFill, 100, 'Complete!');
    log(`Saved: ${filename}`, 'success');
    updateStatus('Read Complete!', 'connected');
    setTimeout(() => hideProgress(el.dumpProgress), 3000);
  } catch (e) {
    log(`Error: ${e.message}`, 'error');
    updateStatus('Failed', 'error');
    hideProgress(el.dumpProgress);
  } finally {
    state.isOperating = false;
    el.dumpBtn.disabled = el.writeBtn.disabled = el.githubBackupBtn.disabled = false;
  }
}

async function happyWrite() {
  if (!state.connected || state.isOperating) return;
  const file = el.writeFile.files[0];
  if (!file) { alert('Select file!'); return; }
  try {
    state.isOperating = true;
    el.dumpBtn.disabled = el.writeBtn.disabled = el.githubBackupBtn.disabled = true;
    log('Starting Happy Write...', 'info');
    await detectFlashSize();
    const flashBytes = getEffectiveFlashBytes();
    const fileMB = (file.size / (1024*1024)).toFixed(2);
    const min = flashBytes * 0.75, max = flashBytes * 1.25;
    if (file.size < min || file.size > max) { alert(`File ${fileMB}MB not in ±25% of ${getEffectiveFlashSize()}MB`); return; }
    if (!confirm(`WRITE FLASH?\nFile: ${file.name} (${fileMB}MB)\nThis will ERASE everything!`)) return;
    updateStatus('Erasing...', 'working');
    await state.esploader.eraseFlash();
    updateStatus('Writing...', 'working');
    const data = new Uint8Array(await file.arrayBuffer());
    const str = String.fromCharCode.apply(null, data.slice(0, flashBytes));
    await state.esploader.writeFlash({ fileArray: [{ data: str, address: 0 }], flashSize: 'keep', compress: true,
      reportProgress: (written, total) => {
        const pct = Math.floor((written/total)*100);
        updateProgress(el.writeProgress, el.writeProgressFill, pct, `${pct}%`);
      }
    });
    updateProgress(el.writeProgress, el.writeProgressFill, 100, 'Complete!');
    log('Write complete!', 'success');
    updateStatus('Write Complete!', 'connected');
    setTimeout(() => hideProgress(el.writeProgress), 3000);
  } catch (e) {
    log(`Error: ${e.message}`, 'error');
    updateStatus('Failed', 'error');
    hideProgress(el.writeProgress);
  } finally {
    state.isOperating = false;
    el.dumpBtn.disabled = el.writeBtn.disabled = el.githubBackupBtn.disabled = false;
  }
}

async function backupGitHub() {
  if (!state.lastDumpData) { alert('Do HAPPY READ first!'); return; }
  const pwd = prompt('Password:');
  if (pwd !== GITHUB.password) { alert('Wrong!'); return; }
  try {
    state.isOperating = true;
    el.githubBackupBtn.disabled = true;
    updateProgress(el.githubProgress, el.githubProgressFill, 20, 'Encoding...');
    let base64 = '';
    for (let i = 0; i < state.lastDumpData.length; i += 1024*1024) {
      base64 += btoa(String.fromCharCode.apply(null, state.lastDumpData.slice(i, i+1024*1024)));
    }
    updateProgress(el.githubProgress, el.githubProgressFill, 60, 'Uploading...');
    const path = `${GITHUB.folder}/${state.lastDumpFilename}`;
    const res = await fetch(`https://api.github.com/repos/${GITHUB.repo}/contents/${path}`, {
      method: 'PUT',
      headers: { 'Authorization': `token ${GITHUB.token}`, 'Content-Type': 'application/json' },
      body: JSON.stringify({ message: `Backup ${state.chipType}`, content: base64, branch: 'main' })
    });
    if (!res.ok) throw new Error(await res.text());
    updateProgress(el.githubProgress, el.githubProgressFill, 100, 'Complete!');
    log('GitHub backup done!', 'success');
    setTimeout(() => hideProgress(el.githubProgress), 3000);
  } catch (e) {
    log(`Error: ${e.message}`, 'error');
    hideProgress(el.githubProgress);
  } finally {
    state.isOperating = false;
    el.githubBackupBtn.disabled = false;
  }
}

// === BACKBLAZE UPLOAD ===
async function sendFileBackup() {
  if (!state.lastSelectedFile) { alert('Select file!'); return; }
  try {
    state.isOperating = true;
    el.sendFileBtn.disabled = true;
    log(`Uploading to Backblaze...`, 'info');
    updateStatus('SMS...', 'working');
    updateProgress(el.sendProgress, el.sendProgressFill, 5, 'SMS...');
    const code = prompt('GitHub SMS code:');
    if (!code || code.length !== 6) throw new Error('Invalid code');
    log('SMS confirmed', 'success');

    let data = new Uint8Array(await state.lastSelectedFile.arrayBuffer());
    let filename = `${state.b2Config.privateFolder}/${state.macAddress || 'unknown'}_${new Date().toISOString().slice(0,10)}.zip`;
    if (!state.lastSelectedFile.name.endsWith('.zip')) {
      const zip = new JSZip();
      zip.file(state.lastSelectedFile.name, data);
      data = new Uint8Array(await zip.generateAsync({type: 'uint8array'}));
    }

    updateProgress(el.sendProgress, el.sendProgressFill, 40, 'Uploading...');
    const url = await backblazeUpload(data, filename);
    updateProgress(el.sendProgress, el.sendProgressFill, 100, 'Done!');
    log(`Saved: ${url}`, 'success');
    alert('Uploaded to Backblaze!');
  } catch (e) {
    log(`Error: ${e.message}`, 'error');
    alert(e.message);
  } finally {
    state.isOperating = false;
    el.sendFileBtn.disabled = false;
    hideProgress(el.sendProgress);
  }
}

async function backblazeUpload(data, filename) {
  const auth = btoa(`${state.b2Config.accountId}:${state.b2Config.appKey}`);
  const authResp = await fetch(`${state.b2Config.apiUrl}/b2api/v2/b2_authorize_account`, { headers: { 'Authorization': `Basic ${auth}` } });
  if (!authResp.ok) throw new Error('Invalid key');
  const authData = await authResp.json();
  const uploadResp = await fetch(`${authData.apiUrl}/b2api/v2/b2_get_upload_url`, {
    method: 'POST', headers: { 'Authorization': authData.authorizationToken },
    body: JSON.stringify({ bucketId: state.b2Config.bucketId })
  });
  const uploadData = await uploadResp.json();
  const sha1 = CryptoJS.SHA1(CryptoJS.lib.WordArray.create(data)).toString();
  const res = await fetch(uploadData.uploadUrl, {
    method: 'POST',
    headers: {
      'Authorization': uploadData.authorizationToken,
      'X-Bz-File-Name': filename,
      'Content-Type': 'application/zip',
      'X-Bz-Content-Sha1': sha1,
      'Content-Length': data.length
    },
    body: data
  });
  if (!res.ok) throw new Error('Upload failed');
  return `https://f000.backblazeb2.com/file/${state.b2Config.bucketName}/${filename}`;
}

// === EVENT LISTENERS ===
el.connectBtn.addEventListener('click', connect);
el.disconnectBtn.addEventListener('click', disconnect);
el.dumpBtn.addEventListener('click', happyRead);
el.writeBtn.addEventListener('click', happyWrite);
el.githubBackupBtn.addEventListener('click', backupGitHub);
el.backupFile.addEventListener('change', e => { state.lastSelectedFile = e.target.files[0]; el.sendFileBtn.disabled = !state.lastSelectedFile; });
el.sendFileBtn.addEventListener('click', sendFileBackup);
el.flashSizeSelect.addEventListener('change', e => { state.flashSizeMode = e.target.value; if(state.connected) updateFlashSizeDisplay(); });

log('System ready!', 'success');
</script>
</body>
</html>
